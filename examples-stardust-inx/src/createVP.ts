// Copyright 2020-2022 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import {
    Credential,
    ProofOptions,
    IotaDocument, IotaIdentityClient
    , IotaDID,
    Timestamp,
    Duration,
    Presentation
} from "@iota/identity-wasm/node/index.js";

import { Client } from "@iota/client-wasm/node/lib/index.js";

import { Converter } from "@iota/util.js";

async function resolveDocument(didClient: IotaIdentityClient, did: string): Promise<IotaDocument> {
    const elements = did.split(":");
    const didResult = IotaDID.fromAliasId(elements[elements.length - 1], elements[elements.length - 2]);

    const resolvedDocument: IotaDocument = await didClient.resolveDid(didResult);
    console.log("Resolved DID document:", JSON.stringify(resolvedDocument, null, 2));

    return resolvedDocument;
}

async function run() {
    const client = new Client({
        primaryNode: "http://52.213.240.168:14265",
        localPow: true,
    });
    const didClient = new IotaIdentityClient(client);

    const issuerDid = "did:iota:tst:0x73871725725fd46a59f25440e29ce99eaad737f9c4f6ee980f642eb10de719d2";
    const privateKey = "0xe9956d529058aaa82e87641a6233e8436112d2e43466e1c511f8f31e3b60ee8cd28dc61055240e04f4f0bcecf20af8d826ca24c12de139700e70f59a65a140f3";

    const holderDid = "did:iota:tst:0xe0051c9a0dba361f6ef050ed2eeab2904491ded689547067539a06860630d336";
    const holderPrivateKey = "0xd601fa2f6bd6acca70c10d9ba15d10da42204af8a5410edd85b77ccfae670dfdce926d2c5136339dcc1310711e205805575da5ccdf4a32d3667af7bf7f99c011";

   const issuerDocument = await resolveDocument(didClient, issuerDid);
   const holderDocument = await resolveDocument(didClient, holderDid);

    // Create a credential subject indicating the degree earned by Alice, linked to their DID.
    const subject = {
        id: "did:iota:tst:0x6abe6ef35e4dfd4242f932d6fbe1b1ae01b87a1b42a49329141602a9222980de",
        name: "Alice",
        degreeName: "Bachelor of Science and Arts",
        degreeType: "BachelorDegree",
        GPA: "4.0",
    };

    // Create an unsigned `UniversityDegree` credential for Alice
    const unsignedVc = new Credential({
        id: "https://example.edu/credentials/3732",
        type: "UniversityDegreeCredential",
        issuer: issuerDid,
        credentialSubject: subject,
    });

    const privateKeyBytes = Converter.hexToBytes(privateKey);
    const holderPrivateKeyBytes = Converter.hexToBytes(holderPrivateKey);

    // Sign Credential.
    let signedVc;

    try {
        signedVc = issuerDocument.signCredential(unsignedVc, privateKeyBytes.slice(0, 32), "#sign-1", ProofOptions.default());
    }
    catch (error) {
        console.error(error);
        return;
    }

    // The issuer is now sure that the credential they are about to issue satisfies their expectations.
    // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
    // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
    const credentialJSON = signedVc.toJSON();
    console.log(`Issued credential: ${JSON.stringify(credentialJSON, null, 2)}`);

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
    const challenge = "475a7984-1bb5-4c4c-a56f-822bccd46440";

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.
    const expires = Timestamp.nowUTC().checkedAdd(Duration.minutes(240));

    // ===========================================================================
    // Step 5: Holder creates a verifiable presentation from the issued credential for the verifier to validate.
    // ===========================================================================

    // Deserialize the credential.
    const receivedVc = Credential.fromJSON(credentialJSON);

    // Create a Verifiable Presentation from the Credential
    const unsignedVp = new Presentation({
        holder: holderDid,
        verifiableCredential: receivedVc,
    });

    // Sign the verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    const signedVp = await holderDocument.signPresentation(
        unsignedVp,
        holderPrivateKeyBytes.slice(0, 32),
        "#sign-1",
        new ProofOptions({
            challenge: challenge,
            expires,
        }),
    );

    // ===========================================================================
    // Step 6: Holder sends a verifiable presentation to the verifier.
    // ===========================================================================

    // Convert the Verifiable Presentation to JSON to send it to the verifier.
    const signedVpJSON = signedVp.toJSON();

    // ====================================
    console.log(`Issued presentation: ${JSON.stringify(signedVpJSON, null, 2)}`);
}

export { };

run().then(() => console.log("Done")).catch(err => console.error(err));
