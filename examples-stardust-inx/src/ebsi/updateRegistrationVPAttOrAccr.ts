// Copyright 2020-2022 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import {
    Credential,
    ProofOptions,
    IotaDocument, IotaIdentityClient, IotaDID,
    Timestamp,
    Duration,
    Presentation,
} from "@iota/identity-wasm/node/index.js";

import { Client } from "@iota/client-wasm/node/lib/index.js";

import { Converter } from "@iota/util.js";

import { Ed25519 } from "@iota/crypto.js";

import * as dotenv from "dotenv";
import * as dotenvExpand from "dotenv-expand";
import { ebsiDids as ebsiDids } from "./dids";
import { post, type Signature } from "../utilHttp";
const theEnv = dotenv.config();
dotenvExpand.expand(theEnv);

const { NODE_ENDPOINT, TOKEN, PLUGIN_ENDPOINT } = process.env;

async function resolveDocument(didClient: IotaIdentityClient, did: string): Promise<IotaDocument> {
    const elements = did.split(":");
    const didResult = IotaDID.fromAliasId(elements[elements.length - 1], elements[elements.length - 2]);

    const resolvedDocument: IotaDocument = await didClient.resolveDid(didResult);
    console.log("Resolved DID document:", JSON.stringify(resolvedDocument, null, 2));

    return resolvedDocument;
}

async function run() {
    const client = new Client({
        primaryNode: {
            url: NODE_ENDPOINT,
            auth: { jwt: TOKEN }
        },
        localPow: true,
    });
    const didClient = new IotaIdentityClient(client);

    const holderDid = ebsiDids.esGovernmentTAO.did;
    const holderPrivateKeySign = ebsiDids.esGovernmentTAO.privateKeySign;

    const holderPrivateKeyDidControl = ebsiDids.esGovernmentTAO.privateKeyDidControl;
    const holderPublicKeyDidControl = ebsiDids.esGovernmentTAO.publicKeyDidControl;

    const holderDocument = await resolveDocument(didClient, holderDid);

    const holderPrivateKeyBytes = Converter.hexToBytes(holderPrivateKeySign);

    const registrationTrail = "urn:trail:iota:ebsi:0x3c802ea821cf0e181f0b49498da70f2f55fec08a212d280ea1f0307cff7191d0";

    // The issuer is now sure that the credential they are about to issue satisfies their expectations.
    // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
    // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
    const credentialJSON = JSON.parse(process.argv[2]);

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
    const challenge = "475a7984-1bb5-4c4c-a56f-822bccd46440";

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.
    const expires = Timestamp.nowUTC().checkedAdd(Duration.minutes(240));

    // ===========================================================================
    // Step 5: Holder creates a verifiable presentation from the issued credential for the verifier to validate.
    // ===========================================================================

    // Deserialize the credential.
    const receivedVc = Credential.fromJSON(credentialJSON);

    // Create a Verifiable Presentation from the Credential
    const unsignedVp = new Presentation({
        holder: holderDid,
        verifiableCredential: receivedVc,
    });

    // Sign the verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    const signedVp = await holderDocument.signPresentation(
        unsignedVp,
        holderPrivateKeyBytes.slice(0, 32),
        "#sign-1",
        new ProofOptions({
            challenge: challenge,
            expires,
        }),
    );

    // ===========================================================================
    // Step 6: Holder sends a verifiable presentation to the verifier.
    // ===========================================================================

    // Convert the Verifiable Presentation to JSON to send it to the verifier.
    const signedVpJSON = signedVp.toJSON();

    // ====================================
    console.log("Issued presentation: \n", JSON.stringify(signedVpJSON, null, 2));

    const registrationResult = await postToPlugin(signedVpJSON, registrationTrail,
        { publicKey: holderPublicKeyDidControl, privateKey: holderPrivateKeyDidControl });

    console.log("Registration Result: ", registrationResult);
}


async function postToPlugin(signedVp: unknown, registrationTrail: string,
    params: { publicKey: string, privateKey: string }): Promise<unknown> {
    const pluginRequest = {
        type: "TransactionRequest",
        registrationTrail,
        credential: signedVp
    };

    const result1 = await post(`${PLUGIN_ENDPOINT}/credentials/registrations`, TOKEN, pluginRequest);

    const nextPayload = result1 as { type: string; txEssenceHash: string; signature?: Signature[] };

    // The result will contain a txEssence that has to be signed
    // Once it is signed it has to be submitted to the plugin again
    const essence = Converter.hexToBytes(nextPayload.txEssenceHash);
    const essenceSigned = Ed25519.sign(Converter.hexToBytes(params.privateKey), essence);

    // Now the essence is signed then the same payload is sent including a signature
    nextPayload.type = "TransactionSignature";
    nextPayload.signature = [{
        publicKey: params.publicKey,
        signature: Converter.bytesToHex(essenceSigned, true)
    }];

    // console.log(JSON.stringify(nextPayload));

    const finalResult = await post(`${PLUGIN_ENDPOINT}/credentials/registrations`, TOKEN, nextPayload);

    return finalResult;
}


export { };

run().then(() => console.log("Done")).catch(err => console.error(err));
